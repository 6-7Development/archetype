<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Embedded AI Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1e1e1e;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
        }

        .agent-widget {
            position: relative;
            width: 280px; 
            height: 320px;
            background: #050505;
            border-radius: 12px;
            border: 1px solid #333;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .widget-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 12px;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .status-badge {
            align-self: flex-start;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #888;
            background: rgba(255,255,255,0.05);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 5px currentColor;
            animation: pulse 2s infinite;
        }

        .mode-selector {
            pointer-events: auto;
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap; /* Allow wrapping for more buttons */
        }

        .mode-btn {
            flex: 1 0 10%; /* Flex basis for grid-like layout */
            height: 4px;
            background: #333;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 20px;
        }
        
        .mode-btn:hover { height: 6px; background: #555; }
        .mode-btn.active { background: currentColor; box-shadow: 0 0 8px currentColor; }

        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>
</head>
<body>

    <div class="agent-widget" id="agentWidget">
        <canvas id="agentCanvas"></canvas>
        
        <div class="widget-ui">
            <div id="statusBadge" class="status-badge" style="color: #ffd700;">
                <span class="dot"></span>
                <span id="statusText">IDLE</span>
            </div>
            
            <div class="mode-selector">
                <!-- Row 1: Core States -->
                <button class="mode-btn" style="color: #ffd700" onclick="agent.setMode('IDLE')" title="Idle"></button>
                <button class="mode-btn" style="color: #a855f7" onclick="agent.setMode('LISTENING')" title="Listening (Voice)"></button>
                <button class="mode-btn" style="color: #38bdf8" onclick="agent.setMode('TYPING')" title="User Typing (Attentive)"></button>
                <button class="mode-btn" style="color: #00f0ff" onclick="agent.setMode('THINKING')" title="Thinking (Neural)"></button>
                <!-- Row 2: Action States -->
                <button class="mode-btn" style="color: #00ff41" onclick="agent.setMode('CODING')" title="Coding (Matrix)"></button>
                <button class="mode-btn" style="color: #ffae00" onclick="agent.setMode('BUILDING')" title="Building (Structure)"></button>
                <button class="mode-btn" style="color: #10b981" onclick="agent.setMode('SUCCESS')" title="Success (Celebration)"></button>
                <button class="mode-btn" style="color: #ef4444" onclick="agent.setMode('ERROR')" title="Error (Glitch)"></button>
                <button class="mode-btn" style="color: #ff0055" onclick="agent.setMode('SWARM')" title="Swarm (Defense)"></button>
            </div>
        </div>
    </div>

    <script>
        class AgentBeeAnimation {
            constructor(containerId, canvasId) {
                this.container = document.getElementById(containerId);
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.config = {
                    colors: {
                        IDLE: '#ffd700',
                        THINKING: '#00f0ff',
                        CODING: '#00ff41',
                        BUILDING: '#ffae00',
                        SWARM: '#ff0055',
                        LISTENING: '#a855f7', // Purple
                        TYPING: '#38bdf8',    // Sky Blue
                        SUCCESS: '#10b981',   // Emerald Green
                        ERROR: '#ef4444'      // Red
                    },
                    workerCount: 8
                };

                this.state = {
                    mode: 'IDLE',
                    w: 0, h: 0,
                    scale: 1, 
                    time: 0,
                    frameId: null
                };

                this.workers = [];
                this.particles = [];

                this.init();
            }

            init() {
                this.resize();
                const observer = new ResizeObserver(() => this.resize());
                observer.observe(this.container);

                for(let i=0; i<this.config.workerCount; i++) {
                    this.workers.push({
                        id: i,
                        // Idle Properties
                        homeAngle: (Math.PI*2/this.config.workerCount) * i,
                        driftOffset: Math.random() * 100,
                        
                        // Coding/Circuit Properties
                        circuitX: 0, 
                        circuitY: 0,
                        circuitDir: i % 2 === 0 ? 1 : -1, 
                        circuitState: 0, 

                        // General Physics
                        angle: (Math.PI*2/this.config.workerCount) * i,
                        radius: 0.35, 
                        tilt: 0,
                        currentX: 0, currentY: 0,
                        targetRadius: 0.35,
                        targetTilt: 0,
                        speed: 0.02
                    });
                }

                this.setMode('IDLE');
                this.animate();
            }

            resize() {
                const rect = this.container.getBoundingClientRect();
                this.state.w = rect.width;
                this.state.h = rect.height;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.state.w * dpr;
                this.canvas.height = this.state.h * dpr;
                this.ctx.scale(dpr, dpr);
                this.state.scale = Math.min(this.state.w, this.state.h); 
            }

            setMode(mode) {
                this.state.mode = mode;
                
                const color = this.config.colors[mode];
                const badge = document.getElementById('statusBadge');
                badge.style.color = color;
                badge.style.borderColor = `rgba(${this.hexToRgb(color)}, 0.2)`;
                document.getElementById('statusText').innerText = mode;
                
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if(btn.title.toUpperCase().includes(mode)) btn.classList.add('active');
                });

                this.particles = []; // Clear particles

                this.workers.forEach(w => {
                    if (mode === 'CODING') {
                        w.circuitX = (Math.random() - 0.5) * 0.6;
                        w.circuitY = (Math.random() - 0.5) * 0.6;
                        w.circuitState = Math.random() > 0.5 ? 0 : 1; 
                    }
                    // Reset targets
                    w.targetRadius = 0.35;
                    w.targetTilt = 0;
                });
            }

            update() {
                this.state.time += 1;
                const s = this.state.scale; 
                const mode = this.state.mode;

                this.workers.forEach(w => {
                    // --- MODE: IDLE ---
                    if (mode === 'IDLE') {
                        w.radius += (0.4 - w.radius) * 0.05;
                        w.tilt += (0 - w.tilt) * 0.05;
                        
                        const driftX = Math.sin(this.state.time * 0.01 + w.driftOffset) * (s * 0.06);
                        const driftY = Math.cos(this.state.time * 0.013 + w.driftOffset) * (s * 0.06);
                        
                        const hx = Math.cos(w.homeAngle) * (w.radius * s);
                        const hy = Math.sin(w.homeAngle) * (w.radius * s);

                        w.currentX = hx + driftX;
                        w.currentY = hy + driftY;
                        w.angle = w.homeAngle; 

                    // --- MODE: LISTENING (Voice EQ) ---
                    } else if (mode === 'LISTENING') {
                        // Bees line up horizontally or in a gentle arc
                        const spacing = (s * 0.8) / this.config.workerCount;
                        const targetX = - (s * 0.4) + (w.id * spacing);
                        
                        // Simulate EQ Waveform height
                        // Use a composite sine wave to simulate voice frequency
                        const wave = Math.sin(this.state.time * 0.2 + w.id) * Math.sin(this.state.time * 0.1) * (s * 0.3);
                        
                        const targetY = wave;

                        w.currentX += (targetX - w.currentX) * 0.1;
                        w.currentY += (targetY - w.currentY) * 0.2; // Snap faster
                        
                        w.angle = -Math.PI/2; // Face UP

                    // --- MODE: USER TYPING (Attentive) ---
                    } else if (mode === 'TYPING') {
                        // Gather at bottom in a semi-circle, looking up/center
                        // "Watching" the user type
                        const arcAngle = Math.PI; // 180 degree arc
                        const angleOffset = Math.PI; // Start from bottom
                        const step = arcAngle / (this.config.workerCount - 1);
                        const currentAngle = angleOffset + (w.id * step);
                        
                        const radius = s * 0.35;
                        const targetX = Math.cos(currentAngle) * radius;
                        const targetY = Math.sin(currentAngle) * (radius * 0.5) + (s*0.2); // Flattened oval at bottom

                        w.currentX += (targetX - w.currentX) * 0.1;
                        w.currentY += (targetY - w.currentY) * 0.1;

                        // Rotate to face center-ish
                        w.angle = Math.atan2(-w.currentY, -w.currentX);

                    // --- MODE: SUCCESS (Celebration) ---
                    } else if (mode === 'SUCCESS') {
                        // Spiraling upwards rapidly
                        w.angle += 0.1;
                        w.radius = 0.4 + Math.sin(this.state.time * 0.1 + w.id)*0.1;
                        
                        const bx = Math.cos(w.angle) * (w.radius * s);
                        const by = Math.sin(w.angle) * (w.radius * s);
                        
                        w.currentX = bx;
                        w.currentY = by;
                        
                        // Hop/Jump effect
                        w.currentY += Math.sin(this.state.time * 0.5 + w.id) * (s * 0.05);

                    // --- MODE: ERROR (Glitch) ---
                    } else if (mode === 'ERROR') {
                        // Random jittery position
                        if (Math.random() > 0.8) {
                            w.currentX = (Math.random() - 0.5) * s * 0.8;
                            w.currentY = (Math.random() - 0.5) * s * 0.8;
                        }
                        // Shake
                        w.currentX += (Math.random() - 0.5) * 10;
                        w.currentY += (Math.random() - 0.5) * 10;
                        w.angle = Math.random() * Math.PI * 2;

                    // --- MODE: THINKING ---
                    } else if (mode === 'THINKING') {
                        const targetTilt = Math.sin(w.id * 132); 
                        w.tilt += (targetTilt - w.tilt) * 0.05;
                        w.radius += (0.3 - w.radius) * 0.05;
                        w.angle += 0.04; 
                        const bx = Math.cos(w.angle) * (w.radius * s);
                        const by = Math.sin(w.angle) * (w.radius * s);
                        w.currentX = bx;
                        w.currentY = by * (1 - Math.abs(w.tilt)*0.4) + (bx * w.tilt * 0.4);

                    // --- MODE: CODING ---
                    } else if (mode === 'CODING') {
                        const speed = 0.005;
                        const limit = 0.35;
                        if (w.circuitState === 0) { 
                            w.circuitX += w.circuitDir * speed;
                            if (Math.abs(w.circuitX) > limit || Math.random() > 0.98) {
                                w.circuitState = 1;
                                if (w.circuitX > limit) w.circuitDir = -1;
                                if (w.circuitX < -limit) w.circuitDir = 1;
                            }
                        } else { 
                            w.circuitY += w.circuitDir * speed;
                            if (Math.abs(w.circuitY) > limit || Math.random() > 0.98) {
                                w.circuitState = 0;
                                if (w.circuitY > limit) w.circuitDir = -1;
                                if (w.circuitY < -limit) w.circuitDir = 1;
                            }
                        }
                        const tx = w.circuitX * s * 1.5;
                        const ty = w.circuitY * s * 1.5;
                        w.currentX += (tx - w.currentX) * 0.1;
                        w.currentY += (ty - w.currentY) * 0.1;
                        w.angle = w.circuitState === 0 ? (w.circuitDir > 0 ? 0 : Math.PI) : (w.circuitDir > 0 ? Math.PI/2 : -Math.PI/2);
                        w.angle -= Math.PI/2; 

                    // --- MODE: BUILDING ---
                    } else if (mode === 'BUILDING') {
                        const hexIdx = w.id % 6;
                        const hexAngle = (Math.PI / 3) * hexIdx;
                        const pulse = Math.sin(this.state.time * 0.1) * 0.02;
                        const tRadius = 0.35 + pulse;
                        const tx = Math.cos(hexAngle) * (tRadius * s);
                        const ty = Math.sin(hexAngle) * (tRadius * s);
                        w.currentX += (tx - w.currentX) * 0.1;
                        w.currentY += (ty - w.currentY) * 0.1;
                        w.angle = Math.atan2(w.currentY, w.currentX);

                    // --- MODE: SWARM ---
                    } else if (mode === 'SWARM') {
                        w.angle += 0.08; 
                        w.radius = 0.35;
                        const wobble = Math.sin(this.state.time * 0.2 + w.id) * (s * 0.05);
                        const bx = Math.cos(w.angle) * (w.radius * s);
                        const by = Math.sin(w.angle) * (w.radius * s);
                        w.currentX = bx + wobble;
                        w.currentY = by + Math.cos(w.angle * 2) * (s*0.1); 
                    }
                });
            }

            draw() {
                const { w, h, scale: s } = this.state;
                const modeColor = this.config.colors[this.state.mode];

                // 1. BACKGROUNDS
                this.ctx.fillStyle = '#050505';
                this.ctx.fillRect(0, 0, w, h);
                
                // CODING RAIN
                if (this.state.mode === 'CODING') {
                    if (Math.random() > 0.8) this.spawnParticle(Math.random()*w - w/2, -h/2, 'code_rain');
                    this.drawParticles(modeColor, true); 
                }
                // BUILDING GRID
                if (this.state.mode === 'BUILDING') {
                    this.drawBlueprintGrid(s, modeColor);
                }
                // LISTENING WAVEFORM
                if (this.state.mode === 'LISTENING') {
                     this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.1)`;
                     this.ctx.beginPath();
                     this.ctx.moveTo(0, h/2);
                     this.ctx.lineTo(w, h/2);
                     this.ctx.stroke();
                }

                const cx = w / 2;
                const cy = h / 2;

                // 2. QUEEN
                this.drawRealQueen(cx, cy, s * 0.14, modeColor);

                // 3. WORKERS & EFFECTS
                this.workers.forEach(worker => {
                    const wx = cx + worker.currentX;
                    const wy = cy + worker.currentY;
                    
                    this.drawRealWorker(wx, wy, s * 0.04, modeColor, worker);
                    
                    // Mode specific lines
                    if (this.state.mode === 'THINKING') {
                        this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.15)`;
                        this.ctx.beginPath();
                        this.ctx.moveTo(cx, cy); 
                        this.ctx.lineTo(wx, wy);
                        this.ctx.stroke();
                    }
                    // Success Particles
                    if (this.state.mode === 'SUCCESS' && Math.random() > 0.8) {
                        this.spawnParticle(worker.currentX, worker.currentY, 'spark');
                    }
                    // Error Particles
                    if (this.state.mode === 'ERROR' && Math.random() > 0.5) {
                        this.spawnParticle(worker.currentX, worker.currentY, 'glitch');
                    }
                });

                // 4. FOREGROUND PARTICLES
                if (this.state.mode !== 'CODING') this.drawParticles(modeColor, false);
                if (this.state.mode === 'CODING') this.drawParticles(modeColor, false);

                // SWARM SHIELD
                if (this.state.mode === 'SWARM') {
                    this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.3)`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, s * 0.45, 0, Math.PI*2);
                    this.ctx.stroke();
                }
                
                // ERROR FLASH
                if (this.state.mode === 'ERROR') {
                    this.ctx.fillStyle = `rgba(255, 0, 0, ${Math.random() * 0.1})`;
                    this.ctx.fillRect(0,0,w,h);
                }
            }

            // ... Reuse existing drawBlueprintGrid ...
            drawBlueprintGrid(s, color) {
                const ctx = this.ctx;
                const cx = this.state.w / 2;
                const cy = this.state.h / 2;
                ctx.strokeStyle = `rgba(${this.hexToRgb(color)}, 0.1)`;
                ctx.lineWidth = 1;
                const r = s * 0.35;
                ctx.beginPath();
                for (let i = 0; i < 7; i++) {
                    const a = (Math.PI / 3) * i;
                    const x = cx + Math.cos(a) * r;
                    const y = cy + Math.sin(a) * r;
                    if (i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI / 3) * i;
                    const x = cx + Math.cos(a) * r;
                    const y = cy + Math.sin(a) * r;
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.5 + Math.sin(this.state.time * 0.1 + i) * 0.5;
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }

            // ... Reuse High Fidelity Queen ...
            drawRealQueen(x, y, size, modeColor) {
                const ctx = this.ctx;
                ctx.save();
                const hover = Math.sin(this.state.time * 0.05) * (size*0.1);
                ctx.translate(x, y + hover);

                ctx.shadowBlur = size * 1.5;
                ctx.shadowColor = modeColor;

                const flap = Math.sin(this.state.time * 0.12) * 0.15;
                ctx.fillStyle = `rgba(${this.hexToRgb(modeColor)}, 0.1)`;
                ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.3)`;
                ctx.lineWidth = 0.5;
                
                [-1, 1].forEach(dir => {
                    ctx.save();
                    ctx.scale(dir, 1);
                    ctx.rotate(Math.PI/8 + flap);
                    ctx.beginPath();
                    ctx.moveTo(0, -size*0.2);
                    ctx.bezierCurveTo(size*1.2, -size*1.5, size*2.5, -size*0.5, size*2.8, size*0.5);
                    ctx.bezierCurveTo(size*1.5, size*1.0, size*0.5, size*0.5, 0, 0);
                    ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.bezierCurveTo(size*0.8, size*1.0, size*1.5, size*1.2, size*1.5, size*0.5);
                    ctx.bezierCurveTo(size*0.5, size*0.2, 0, 0, 0, 0);
                    ctx.fill(); ctx.stroke();
                    ctx.restore();
                });
                ctx.shadowBlur = 0; 
                ctx.strokeStyle = '#111'; ctx.lineWidth = size * 0.08; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                for(let i=0; i<3; i++) {
                    const ly = -size*0.1 + (i*size*0.2);
                    ctx.beginPath(); ctx.moveTo(size*0.1, ly); ctx.lineTo(size*0.5, ly + size*0.2); ctx.lineTo(size*0.6, ly + size*0.5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-size*0.1, ly); ctx.lineTo(-size*0.5, ly + size*0.2); ctx.lineTo(-size*0.6, ly + size*0.5); ctx.stroke();
                }
                const abGrad = ctx.createLinearGradient(-size*0.3, 0, size*0.3, 0);
                abGrad.addColorStop(0, '#000'); abGrad.addColorStop(0.3, '#ffd700'); abGrad.addColorStop(0.7, '#ffd700'); abGrad.addColorStop(1, '#000');
                for(let i=0; i<5; i++) {
                    const segY = size*0.3 + (i * size*0.25);
                    const segW = (size*0.5) * (1 - i*0.15); const segH = size*0.3;
                    ctx.fillStyle = (i % 2 === 0) ? '#111' : abGrad;
                    ctx.beginPath(); ctx.ellipse(0, segY, segW, segH, 0, 0, Math.PI*2); ctx.fill();
                }
                const thGrad = ctx.createRadialGradient(-size*0.1, -size*0.1, 0, 0, 0, size*0.5);
                thGrad.addColorStop(0, '#444'); thGrad.addColorStop(1, '#050505');
                ctx.fillStyle = thGrad; ctx.beginPath(); ctx.ellipse(0, 0, size*0.4, size*0.45, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = modeColor; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(0, -size*0.3, size*0.2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
                ctx.translate(0, -size*0.5); ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.ellipse(0, 0, size*0.35, size*0.3, 0, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 5; ctx.shadowColor = modeColor; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(-size*0.2, -size*0.1, size*0.1, size*0.15, -0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(size*0.2, -size*0.1, size*0.1, size*0.15, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = modeColor; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(-size*0.1, -size*0.2); ctx.quadraticCurveTo(-size*0.4, -size*0.6, -size*0.3, -size*0.8); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(size*0.1, -size*0.2); ctx.quadraticCurveTo(size*0.4, -size*0.6, size*0.3, -size*0.8); ctx.stroke();
                ctx.strokeStyle = '#ffd700'; ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(-size*0.3, -size*0.4); ctx.lineTo(-size*0.4, -size*0.9); ctx.lineTo(-size*0.15, -size*0.6); 
                ctx.lineTo(0, -size*1.1); ctx.lineTo(size*0.15, -size*0.6); ctx.lineTo(size*0.4, -size*0.9); ctx.lineTo(size*0.3, -size*0.4); ctx.closePath();
                ctx.fill(); ctx.stroke();
                ctx.restore();
            }

            // ... Reuse High Fidelity Worker ...
            drawRealWorker(x, y, size, modeColor, w) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                
                if (this.state.mode === 'CODING') ctx.rotate(w.angle + Math.PI/2); 
                else if (this.state.mode === 'BUILDING') {
                    const dx = x - (this.state.w/2); const dy = y - (this.state.h/2);
                    ctx.rotate(Math.atan2(dy, dx) + Math.PI/2);
                } else if (this.state.mode === 'LISTENING') ctx.rotate(0); // Face Up
                else if (this.state.mode === 'TYPING') ctx.rotate(w.angle + Math.PI/2); 
                else ctx.rotate(w.angle + Math.PI/2);

                ctx.strokeStyle = '#000'; ctx.lineWidth = size * 0.1;
                for(let i=0; i<3; i++) {
                   const ly = -size*0.2 + (i*size*0.3);
                   ctx.beginPath(); ctx.moveTo(size*0.3, ly); ctx.lineTo(size*0.8, ly+size*0.3); ctx.stroke();
                   ctx.beginPath(); ctx.moveTo(-size*0.3, ly); ctx.lineTo(-size*0.8, ly+size*0.3); ctx.stroke();
                }
                const f = Math.sin(this.state.time * 0.5 + w.id);
                ctx.fillStyle = `rgba(${this.hexToRgb(modeColor)}, 0.2)`;
                ctx.beginPath(); ctx.ellipse(-size*0.7, size*0.2, size*0.8, size*0.4*(1+f*0.5), -0.5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(size*0.7, size*0.2, size*0.8, size*0.4*(1+f*0.5), 0.5, 0, Math.PI*2); ctx.fill();
                const grad = ctx.createLinearGradient(-size*0.5, 0, size*0.5, 0);
                grad.addColorStop(0, '#000'); grad.addColorStop(0.4, '#eab308'); grad.addColorStop(0.6, '#eab308'); grad.addColorStop(1, '#000');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(0, size*0.6, size*0.55, size*0.7, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.beginPath(); ctx.rect(-size*0.5, size*0.5, size, size*0.2); ctx.fill();
                ctx.beginPath(); ctx.rect(-size*0.4, size*0.9, size*0.8, size*0.15); ctx.fill();
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(0, -size*0.1, size*0.5, size*0.5, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -size*0.5, size*0.35, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = modeColor;
                ctx.beginPath(); ctx.arc(-size*0.2, -size*0.6, size*0.1, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(size*0.2, -size*0.6, size*0.1, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            spawnParticle(x, y, type) {
                this.particles.push({
                    x, y, type,
                    life: 1.0,
                    val: Math.random() > 0.5 ? '1' : '0'
                });
            }

            drawParticles(color, backgroundLayer) {
                const cx = this.state.w / 2;
                const cy = this.state.h / 2;

                for(let i=this.particles.length-1; i>=0; i--) {
                    let p = this.particles[i];
                    
                    if (p.type === 'code_rain') {
                        if (!backgroundLayer) continue;
                        p.y += 2; p.life -= 0.01;
                        this.ctx.fillStyle = `rgba(0, 255, 65, ${p.life * 0.3})`;
                        this.ctx.font = '10px monospace'; this.ctx.fillText(p.val, cx + p.x, cy + p.y);
                    } 
                    else if (p.type === 'pixel_trail') {
                        if (backgroundLayer) continue;
                        p.life -= 0.05;
                        this.ctx.fillStyle = color; this.ctx.globalAlpha = p.life;
                        this.ctx.fillRect(cx + p.x, cy + p.y, 2, 2); this.ctx.globalAlpha = 1;
                    } 
                    else if (p.type === 'spark') {
                        if (backgroundLayer) continue;
                        p.life -= 0.02; p.y -= 1; p.x += (Math.random()-0.5)*2;
                        this.ctx.fillStyle = '#ffd700'; this.ctx.globalAlpha = p.life;
                        this.ctx.beginPath(); this.ctx.arc(cx + p.x, cy + p.y, 2, 0, Math.PI*2); this.ctx.fill(); this.ctx.globalAlpha = 1;
                    }
                    else if (p.type === 'glitch') {
                        if (backgroundLayer) continue;
                        p.life -= 0.1;
                        this.ctx.fillStyle = '#ff0000'; this.ctx.globalAlpha = p.life;
                        this.ctx.fillRect(cx + p.x + (Math.random()-0.5)*20, cy + p.y, 10, 2); this.ctx.globalAlpha = 1;
                    }

                    if(p.life <= 0) this.particles.splice(i, 1);
                }
            }

            animate() {
                this.update();
                this.draw();
                this.state.frameId = requestAnimationFrame(() => this.animate());
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255,255,255';
            }
        }

        const agent = new AgentBeeAnimation('agentWidget', 'agentCanvas');
    </script>
</body>
</html>


