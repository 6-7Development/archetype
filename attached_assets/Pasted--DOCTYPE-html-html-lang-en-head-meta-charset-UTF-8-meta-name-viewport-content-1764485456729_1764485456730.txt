<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0b0500">
    <title>Beehive AI Agent - Mobile</title>
    <style>
        :root {
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* CARD CONTAINER */
        .agent-widget {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 480px; /* Mobile constraint */
            max-height: 850px;
            background: #0b0500;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* No border radius on full mobile screen, or rounded if floating */
        }

        @media (min-width: 481px) {
            .agent-widget {
                width: 360px;
                height: 640px;
                border-radius: 32px;
                border: 1px solid #333;
                box-shadow: 0 20px 60px rgba(0,0,0,0.7);
            }
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Critical for custom touch handling */
        }

        /* BOTTOM CONTROL SHEET */
        .widget-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px 0 calc(20px + var(--safe-bottom)) 0;
            background: linear-gradient(to top, rgba(11, 5, 0, 0.98) 20%, rgba(11, 5, 0, 0.8) 50%, transparent);
            display: flex;
            flex-direction: column;
            gap: 16px;
            pointer-events: none; /* Let touches pass through to canvas where empty */
        }

        /* STATUS BADGE */
        .status-container {
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .status-badge {
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #d4af37;
            background: rgba(255, 215, 0, 0.05);
            padding: 8px 16px;
            border-radius: 100px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            box-shadow: 0 0 10px currentColor;
            animation: pulse 2s infinite;
        }

        /* SCROLLABLE MODES */
        .mode-scroll-container {
            pointer-events: auto;
            width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            padding: 0 24px;
            -ms-overflow-style: none;
            scrollbar-width: none;
            /* Smooth momentum scrolling on iOS */
            -webkit-overflow-scrolling: touch; 
        }
        .mode-scroll-container::-webkit-scrollbar { display: none; }

        .mode-track {
            display: inline-flex;
            gap: 12px;
            padding-right: 24px; /* Right padding for scroll */
        }

        .mode-btn {
            height: 44px; /* Large touch target */
            padding: 0 20px;
            border-radius: 22px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.7);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-tap-highlight-color: transparent;
        }
        
        .mode-btn:active { transform: scale(0.96); background: rgba(255,255,255,0.1); }
        
        .mode-btn.active { 
            background: rgba(255,255,255,0.95); 
            color: #000;
            border-color: transparent;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            font-weight: 700;
        }

        /* Specific active colors override via JS, but base style above */

        @keyframes pulse { 0%, 100% { opacity: 0.4; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.2); } }
        
        /* Tap hint animation */
        .tap-hint {
            position: absolute;
            width: 40px; height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            pointer-events: none;
            animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
            opacity: 0;
        }
        @keyframes ping {
            75%, 100% { transform: scale(2); opacity: 0; }
        }
    </style>
</head>
<body>

    <div class="agent-widget" id="agentWidget">
        <canvas id="agentCanvas"></canvas>
        
        <div class="widget-ui">
            <div class="status-container">
                <div id="statusBadge" class="status-badge" style="color: #ffd700;">
                    <span class="dot"></span>
                    <span id="statusText">HIVE IDLE</span>
                </div>
            </div>
            
            <div class="mode-scroll-container">
                <div class="mode-track">
                    <button class="mode-btn active" data-color="#ffd700" onclick="agent.setMode('IDLE')">Idle</button>
                    <button class="mode-btn" data-color="#a855f7" onclick="agent.setMode('LISTENING')">Voice</button>
                    <button class="mode-btn" data-color="#38bdf8" onclick="agent.setMode('TYPING')">Typing</button>
                    <button class="mode-btn" data-color="#00f0ff" onclick="agent.setMode('THINKING')">Think</button>
                    <button class="mode-btn" data-color="#00ff41" onclick="agent.setMode('CODING')">Code</button>
                    <button class="mode-btn" data-color="#ffae00" onclick="agent.setMode('BUILDING')">Build</button>
                    <button class="mode-btn" data-color="#10b981" onclick="agent.setMode('SUCCESS')">Success</button>
                    <button class="mode-btn" data-color="#ef4444" onclick="agent.setMode('ERROR')">Error</button>
                    <button class="mode-btn" data-color="#ff0055" onclick="agent.setMode('SWARM')">Swarm</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AgentBeeAnimation {
            constructor(containerId, canvasId) {
                this.container = document.getElementById(containerId);
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d', { alpha: false }); // Optimize for no transparency
                
                this.config = {
                    colors: {
                        IDLE: '#ffd700',
                        THINKING: '#00f0ff',
                        CODING: '#00ff41',
                        BUILDING: '#ffae00',
                        SWARM: '#ff0055',
                        LISTENING: '#a855f7', 
                        TYPING: '#38bdf8',    
                        SUCCESS: '#10b981',   
                        ERROR: '#ef4444'      
                    },
                    // Mobile Optimization: Adjust count based on screen width
                    workerCount: window.innerWidth < 400 ? 6 : 8
                };

                this.state = {
                    mode: 'IDLE',
                    w: 0, h: 0,
                    scale: 1, 
                    time: 0,
                    frameId: null,
                    shake: 0,
                    touchX: null,
                    touchY: null,
                    isTouching: false
                };

                this.workers = [];
                this.particles = [];
                this.honeySplashes = [];

                this.init();
                this.setupTouch();
            }

            setupTouch() {
                // Interactive Touch Logic
                const handleTouch = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches ? e.touches[0] : e;
                    this.state.touchX = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
                    this.state.touchY = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
                    this.state.isTouching = true;
                    
                    // If tap, spawn slight ripple
                    if (e.type === 'touchstart' || e.type === 'mousedown') {
                        // Optional: small reaction on tap
                    }
                };

                const endTouch = () => {
                    this.state.isTouching = false;
                    this.state.touchX = null;
                    this.state.touchY = null;
                };

                this.canvas.addEventListener('touchstart', handleTouch, {passive: true});
                this.canvas.addEventListener('touchmove', handleTouch, {passive: true});
                this.canvas.addEventListener('touchend', endTouch);
                this.canvas.addEventListener('mousedown', handleTouch);
                this.canvas.addEventListener('mousemove', (e) => {
                    if (e.buttons === 1) handleTouch(e);
                });
                this.canvas.addEventListener('mouseup', endTouch);
            }

            init() {
                this.resize();
                const observer = new ResizeObserver(() => this.resize());
                observer.observe(this.container);

                for(let i=0; i<this.config.workerCount; i++) {
                    this.workers.push({
                        id: i,
                        homeAngle: (Math.PI*2/this.config.workerCount) * i,
                        driftOffset: Math.random() * 100,
                        circuitX: 0, circuitY: 0,
                        circuitDir: i % 2 === 0 ? 1 : -1, circuitState: 0, 
                        angle: (Math.PI*2/this.config.workerCount) * i,
                        radius: 0.35, tilt: 0,
                        currentX: 0, currentY: 0,
                        targetRadius: 0.35, targetTilt: 0, speed: 0.02
                    });
                }
                
                this.spawnAtmosphere('IDLE');
                this.setMode('IDLE');
                this.animate();
            }

            resize() {
                const rect = this.container.getBoundingClientRect();
                this.state.w = rect.width;
                this.state.h = rect.height;
                const dpr = Math.min(window.devicePixelRatio, 2); // Cap pixel ratio for performance
                this.canvas.width = this.state.w * dpr;
                this.canvas.height = this.state.h * dpr;
                this.ctx.scale(dpr, dpr);
                // Scale calculations based on width to keep things visible
                this.state.scale = this.state.w; 
            }

            setMode(mode) {
                this.spawnHoneySplash();
                
                if (mode === 'SUCCESS') this.spawnExplosion('confetti', 20); // Reduced for mobile
                if (mode === 'ERROR') {
                    this.state.shake = 15;
                    this.spawnExplosion('glitch', 10);
                }
                
                if (mode === 'CODING' || this.state.mode === 'CODING') this.particles = [];

                this.state.mode = mode;
                const color = this.config.colors[mode];
                
                // UI Updates
                const badge = document.getElementById('statusBadge');
                badge.style.color = color;
                badge.style.borderColor = `rgba(${this.hexToRgb(color)}, 0.3)`;
                badge.style.background = `rgba(${this.hexToRgb(color)}, 0.08)`;
                document.getElementById('statusText').innerText = mode;
                
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    const btnColor = btn.getAttribute('data-color');
                    btn.classList.remove('active');
                    btn.style.background = 'rgba(255,255,255,0.06)';
                    btn.style.color = 'rgba(255,255,255,0.7)';
                    btn.style.boxShadow = 'none';
                    
                    if(btn.innerText.toUpperCase() === mode || (mode === 'LISTENING' && btn.innerText === 'Voice') || (mode === 'TYPING' && btn.innerText === 'Typing') || (mode === 'THINKING' && btn.innerText === 'Think') || (mode === 'CODING' && btn.innerText === 'Code') || (mode === 'BUILDING' && btn.innerText === 'Build')) {
                        btn.classList.add('active');
                        btn.style.background = color; // Active is fully colored on mobile for clarity
                        btn.style.color = '#000'; // Contrast text
                        btn.style.boxShadow = `0 4px 15px rgba(${this.hexToRgb(color)}, 0.4)`;
                    }
                });

                this.workers.forEach(w => {
                    if (mode === 'CODING') {
                        w.circuitX = (Math.random() - 0.5) * 0.6;
                        w.circuitY = (Math.random() - 0.5) * 0.6;
                        w.circuitState = Math.random() > 0.5 ? 0 : 1; 
                    }
                    w.targetRadius = 0.35; w.targetTilt = 0;
                });
            }

            update() {
                this.state.time += 1;
                const s = this.state.scale; 
                const mode = this.state.mode;

                if (this.state.shake > 0) this.state.shake *= 0.9;
                if (this.state.shake < 0.5) this.state.shake = 0;

                // Atmosphere Throttled for Mobile
                if (mode === 'IDLE' && Math.random() > 0.98) this.spawnParticle(0,0,'dust');
                if (mode === 'CODING' && Math.random() > 0.9) this.spawnParticle(Math.random()*this.state.w - this.state.w/2, -this.state.h/2, 'code_rain');

                // --- TOUCH INTERACTION TARGET ---
                // If touching, create a virtual attraction point
                let attractX = 0, attractY = 0;
                if (this.state.isTouching) {
                    // Convert canvas coord to center-relative
                    attractX = (this.state.touchX / window.devicePixelRatio) - (this.state.w/2);
                    attractY = (this.state.touchY / window.devicePixelRatio) - (this.state.h/2);
                }

                this.workers.forEach(w => {
                    let tx = 0, ty = 0;
                    
                    // Base Mode Logic
                    if (mode === 'IDLE') {
                        w.radius += (0.35 - w.radius) * 0.05; w.tilt += (0 - w.tilt) * 0.05;
                        const driftX = Math.sin(this.state.time * 0.01 + w.driftOffset) * (s * 0.06);
                        const driftY = Math.cos(this.state.time * 0.013 + w.driftOffset) * (s * 0.06);
                        const hx = Math.cos(w.homeAngle) * (w.radius * s);
                        const hy = Math.sin(w.homeAngle) * (w.radius * s);
                        w.currentX = hx + driftX; w.currentY = hy + driftY; w.angle = w.homeAngle; 
                    } else if (mode === 'LISTENING') {
                        const spacing = (s * 0.7) / this.config.workerCount;
                        const targetX = - (s * 0.35) + (w.id * spacing);
                        const wave = Math.sin(this.state.time * 0.2 + w.id) * Math.sin(this.state.time * 0.1) * (s * 0.3);
                        w.currentX += (targetX - w.currentX) * 0.1; w.currentY += (wave - w.currentY) * 0.2; w.angle = -Math.PI/2;
                    } else if (mode === 'TYPING') {
                        const arcAngle = Math.PI; const angleOffset = Math.PI;
                        const step = arcAngle / (this.config.workerCount - 1);
                        const currentAngle = angleOffset + (w.id * step);
                        const targetX = Math.cos(currentAngle) * (s*0.35);
                        const targetY = Math.sin(currentAngle) * (s*0.175) + (s*0.2); 
                        w.currentX += (targetX - w.currentX) * 0.1; w.currentY += (targetY - w.currentY) * 0.1; w.angle = Math.atan2(-w.currentY, -w.currentX);
                    } else if (mode === 'SUCCESS') {
                        w.angle += 0.1; w.radius = 0.4 + Math.sin(this.state.time * 0.1 + w.id)*0.1;
                        w.currentX = Math.cos(w.angle) * (w.radius * s); w.currentY = Math.sin(w.angle) * (w.radius * s);
                        w.currentY += Math.sin(this.state.time * 0.5 + w.id) * (s * 0.05);
                    } else if (mode === 'ERROR') {
                        if (Math.random() > 0.8) { w.currentX = (Math.random() - 0.5) * s * 0.8; w.currentY = (Math.random() - 0.5) * s * 0.8; }
                        w.currentX += (Math.random() - 0.5) * 10; w.currentY += (Math.random() - 0.5) * 10;
                    } else if (mode === 'THINKING') {
                        const targetTilt = Math.sin(w.id * 132); w.tilt += (targetTilt - w.tilt) * 0.05;
                        w.radius += (0.3 - w.radius) * 0.05; w.angle += 0.04; 
                        const bx = Math.cos(w.angle) * (w.radius * s); const by = Math.sin(w.angle) * (w.radius * s);
                        w.currentX = bx; w.currentY = by * (1 - Math.abs(w.tilt)*0.4) + (bx * w.tilt * 0.4);
                    } else if (mode === 'CODING') {
                        const speed = 0.005; const limit = 0.35;
                        if (w.circuitState === 0) { 
                            w.circuitX += w.circuitDir * speed;
                            if (Math.abs(w.circuitX) > limit || Math.random() > 0.98) { w.circuitState = 1; if (w.circuitX > limit) w.circuitDir = -1; if (w.circuitX < -limit) w.circuitDir = 1; }
                        } else { 
                            w.circuitY += w.circuitDir * speed;
                            if (Math.abs(w.circuitY) > limit || Math.random() > 0.98) { w.circuitState = 0; if (w.circuitY > limit) w.circuitDir = -1; if (w.circuitY < -limit) w.circuitDir = 1; }
                        }
                        const tx = w.circuitX * s * 1.5; const ty = w.circuitY * s * 1.5;
                        w.currentX += (tx - w.currentX) * 0.1; w.currentY += (ty - w.currentY) * 0.1; w.angle = w.circuitState === 0 ? (w.circuitDir > 0 ? 0 : Math.PI) : (w.circuitDir > 0 ? Math.PI/2 : -Math.PI/2); w.angle -= Math.PI/2; 
                    } else if (mode === 'BUILDING') {
                        const hexIdx = w.id % 6; const hexAngle = (Math.PI / 3) * hexIdx;
                        const pulse = Math.sin(this.state.time * 0.1) * 0.02; const tRadius = 0.35 + pulse;
                        const tx = Math.cos(hexAngle) * (tRadius * s); const ty = Math.sin(hexAngle) * (tRadius * s);
                        w.currentX += (tx - w.currentX) * 0.1; w.currentY += (ty - w.currentY) * 0.1; w.angle = Math.atan2(w.currentY, w.currentX);
                    } else if (mode === 'SWARM') {
                        w.angle += 0.08; w.radius = 0.35;
                        const wobble = Math.sin(this.state.time * 0.2 + w.id) * (s * 0.05);
                        const bx = Math.cos(w.angle) * (w.radius * s); const by = Math.sin(w.angle) * (w.radius * s);
                        w.currentX = bx + wobble; w.currentY = by + Math.cos(w.angle * 2) * (s*0.1); 
                    }

                    // --- TOUCH INFLUENCE ---
                    // If touching, workers gently Lerp towards the finger
                    if (this.state.isTouching) {
                        w.currentX += (attractX - w.currentX) * 0.05;
                        w.currentY += (attractY - w.currentY) * 0.05;
                        // Face the finger
                        w.angle = Math.atan2(attractY - w.currentY, attractX - w.currentX);
                    }
                });
            }

            draw() {
                const { w, h, scale: s } = this.state;
                const modeColor = this.config.colors[this.state.mode];
                const cx = w / 2;
                const cy = h / 2;

                this.ctx.save();
                if (this.state.shake > 0) {
                    const sx = (Math.random() - 0.5) * this.state.shake;
                    const sy = (Math.random() - 0.5) * this.state.shake;
                    this.ctx.translate(sx, sy);
                }

                // 1. HONEYCOMB BACKGROUND
                this.drawHoneycomb(w, h, s);

                // BACKGROUND LAYERS
                if (this.state.mode === 'THINKING') this.drawNeuralBackground(cx, cy, s, modeColor);
                if (this.state.mode === 'BUILDING') this.drawBlueprintGrid(s, modeColor);
                if (this.state.mode === 'LISTENING') {
                     this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.15)`;
                     this.ctx.lineWidth = 2;
                     this.ctx.beginPath(); this.ctx.moveTo(0, h/2); this.ctx.lineTo(w, h/2); this.ctx.stroke();
                }

                // 2. HONEY SPLASHES
                this.drawHoneySplashes(cx, cy, s);

                // 3. QUEEN
                this.drawRealQueen(cx, cy, s * 0.14, modeColor);

                // 4. WORKERS
                this.workers.forEach(worker => {
                    const wx = cx + worker.currentX;
                    const wy = cy + worker.currentY;
                    this.drawRealWorker(wx, wy, s * 0.045, modeColor, worker); // Slightly bigger for mobile visibility
                    
                    if (this.state.mode === 'THINKING') {
                        this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.15)`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath(); this.ctx.moveTo(cx, cy); this.ctx.lineTo(wx, wy); this.ctx.stroke();
                    }
                });

                // 5. PARTICLES (Combined pass for mobile perf)
                this.drawParticles(modeColor);

                if (this.state.mode === 'SWARM') {
                    this.ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.3)`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath(); this.ctx.arc(cx, cy, s * 0.45, 0, Math.PI*2); this.ctx.stroke();
                }

                this.ctx.restore(); 
            }

            // --- OPTIMIZED DRAWING FUNCTIONS ---

            drawHoneycomb(w, h, s) {
                // Simplified Fill
                this.ctx.fillStyle = '#0b0500';
                this.ctx.fillRect(-20, -20, w+40, h+40);

                const hexSize = s * 0.18; // Larger hexes for mobile legibility
                const hexH = hexSize * 2;
                const hexW = Math.sqrt(3) * hexSize;
                const rows = Math.ceil(h / (hexH * 0.75)) + 1;
                const cols = Math.ceil(w / hexW) + 1;

                this.ctx.strokeStyle = '#1a1005';
                this.ctx.lineWidth = 1;
                this.ctx.fillStyle = '#0f0800'; // Flat color instead of gradient per cell for mobile perf

                for (let r = -1; r < rows; r++) {
                    for (let c = -1; c < cols; c++) {
                        const xOffset = (r % 2) * (hexW / 2);
                        const x = c * hexW + xOffset;
                        const y = r * (hexH * 0.75);
                        this.drawHexagon(x, y, hexSize);
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                }
                
                // Vignette
                const cx = w/2;
                const cy = h/2;
                const grad = this.ctx.createRadialGradient(cx, cy, s*0.2, cx, cy, s*0.9);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(1, 'rgba(0,0,0,0.9)');
                this.ctx.fillStyle = grad;
                this.ctx.fillRect(0,0,w,h);
            }

            drawHexagon(x, y, r) {
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    this.ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
                }
                this.ctx.closePath();
            }

            spawnHoneySplash() {
                // Reduced particle count for mobile splash
                const count = window.innerWidth < 400 ? 8 : 12;
                for(let i=0; i<count; i++) {
                    const angle = (Math.PI*2 / count) * i;
                    this.honeySplashes.push({
                        x: 0, y: 0, angle: angle, speed: 4 + Math.random()*4,
                        size: 3 + Math.random()*3, life: 1.0, stretch: 1.0
                    });
                }
            }

            drawHoneySplashes(cx, cy, s) {
                for(let i=this.honeySplashes.length-1; i>=0; i--) {
                    let d = this.honeySplashes[i];
                    d.life -= 0.02; d.speed *= 0.95; d.stretch += 0.1;
                    d.x += Math.cos(d.angle) * d.speed; d.y += Math.sin(d.angle) * d.speed;

                    if(d.life <= 0) { this.honeySplashes.splice(i, 1); continue; }

                    this.ctx.save();
                    this.ctx.translate(cx + d.x, cy + d.y);
                    this.ctx.rotate(d.angle);
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.beginPath();
                    this.ctx.ellipse(0, 0, d.size * d.stretch, d.size, 0, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#fff'; // Highlight
                    this.ctx.beginPath();
                    this.ctx.ellipse(-d.size*0.2, -d.size*0.2, d.size*0.3, d.size*0.2, 0,0,Math.PI*2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
            }

            spawnExplosion(type, count) {
                for(let i=0; i<count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    this.particles.push({
                        x: 0, y: 0, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        type: type, life: 1.0,
                        val: type === 'code_rain' ? (Math.random()>0.5?'1':'0') : null
                    });
                }
            }

            spawnAtmosphere(mode) {
                const count = window.innerWidth < 400 ? 8 : 15;
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x: (Math.random()-0.5) * this.state.scale, y: (Math.random()-0.5) * this.state.scale,
                        type: 'dust', life: Math.random(), dx: (Math.random()-0.5)*0.5, dy: (Math.random()-0.5)*0.5
                    });
                }
            }

            spawnParticle(x, y, type) {
                this.particles.push({
                    x, y, type, life: 1.0,
                    dx: (Math.random()-0.5) * (this.state.scale * 0.015),
                    dy: (Math.random()-0.5) * (this.state.scale * 0.015),
                    val: Math.random() > 0.5 ? '1' : '0'
                });
            }

            drawParticles(color) {
                const cx = this.state.w / 2;
                const cy = this.state.h / 2;
                for(let i=this.particles.length-1; i>=0; i--) {
                    let p = this.particles[i];
                    
                    if (p.type === 'code_rain') {
                        p.y += 4; p.life -= 0.01;
                        this.ctx.fillStyle = `rgba(0, 255, 65, ${p.life * 0.5})`;
                        this.ctx.font = '12px monospace'; this.ctx.fillText(p.val, cx + p.x, cy + p.y);
                    } else if (p.type === 'dust') {
                        p.x += p.dx; p.y += p.dy;
                        if(p.life < 1) p.life += 0.01;
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        this.ctx.beginPath(); this.ctx.arc(cx + p.x, cy + p.y, 1.5, 0, Math.PI*2); this.ctx.fill();
                        if(Math.abs(p.x) > this.state.w/2) p.x *= -1; if(Math.abs(p.y) > this.state.h/2) p.y *= -1;
                    } else if (p.type === 'confetti') {
                        p.x += p.dx; p.y += p.dy; p.dy += 0.2; 
                        p.life -= 0.015;
                        this.ctx.fillStyle = `rgba(${this.hexToRgb(p.dx > 0 ? '#ffd700' : '#ffffff')}, ${p.life})`;
                        this.ctx.fillRect(cx + p.x, cy + p.y, 4, 4);
                    } else if (p.type === 'glitch') {
                        p.life -= 0.1;
                        this.ctx.fillStyle = '#ff0000'; 
                        this.ctx.fillRect(cx + p.x + (Math.random()-0.5)*30, cy + p.y, 15, 3); 
                    }
                    if(p.life <= 0) this.particles.splice(i, 1);
                }
            }

            drawNeuralBackground(cx, cy, s, color) {
                this.ctx.strokeStyle = `rgba(${this.hexToRgb(color)}, 0.05)`;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for(let i=0; i<6; i++) {
                    const r = s * 0.5;
                    const a = (Math.PI / 3) * i + (this.state.time * 0.005);
                    this.ctx.moveTo(cx, cy);
                    this.ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
                }
                this.ctx.stroke();
            }

            drawBlueprintGrid(s, color) {
                const cx = this.state.w / 2; const cy = this.state.h / 2;
                this.ctx.strokeStyle = `rgba(${this.hexToRgb(color)}, 0.1)`; this.ctx.lineWidth = 1;
                const r = s * 0.35;
                this.ctx.beginPath();
                for (let i = 0; i < 7; i++) { const a = (Math.PI / 3) * i; const x = cx + Math.cos(a) * r; const y = cy + Math.sin(a) * r; if (i===0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y); }
                this.ctx.stroke();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI / 3) * i; const x = cx + Math.cos(a) * r; const y = cy + Math.sin(a) * r;
                    this.ctx.fillStyle = color; this.ctx.globalAlpha = 0.5 + Math.sin(this.state.time * 0.1 + i) * 0.5;
                    this.ctx.beginPath(); this.ctx.arc(x, y, 3, 0, Math.PI*2); this.ctx.fill(); this.ctx.globalAlpha = 1.0;
                }
            }

            drawRealQueen(x, y, size, modeColor) {
                // High Fidelity Queen (Same geometry, simplified calls)
                const ctx = this.ctx; ctx.save();
                const hover = Math.sin(this.state.time * 0.05) * (size*0.1); ctx.translate(x, y + hover);
                const flap = Math.sin(this.state.time * 0.12) * 0.15;
                ctx.fillStyle = `rgba(${this.hexToRgb(modeColor)}, 0.1)`; ctx.strokeStyle = `rgba(${this.hexToRgb(modeColor)}, 0.3)`; ctx.lineWidth = 0.5;
                [-1, 1].forEach(dir => {
                    ctx.save(); ctx.scale(dir, 1); ctx.rotate(Math.PI/8 + flap);
                    ctx.beginPath(); ctx.moveTo(0, -size*0.2); ctx.bezierCurveTo(size*1.2, -size*1.5, size*2.5, -size*0.5, size*2.8, size*0.5); ctx.bezierCurveTo(size*1.5, size*1.0, size*0.5, size*0.5, 0, 0); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(size*0.8, size*1.0, size*1.5, size*1.2, size*1.5, size*0.5); ctx.bezierCurveTo(size*0.5, size*0.2, 0, 0, 0, 0); ctx.fill(); ctx.stroke(); ctx.restore();
                });
                ctx.strokeStyle = '#111'; ctx.lineWidth = size * 0.08; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                for(let i=0; i<3; i++) { const ly = -size*0.1 + (i*size*0.2); ctx.beginPath(); ctx.moveTo(size*0.1, ly); ctx.lineTo(size*0.5, ly + size*0.2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-size*0.1, ly); ctx.lineTo(-size*0.5, ly + size*0.2); ctx.stroke(); }
                const abGrad = ctx.createLinearGradient(-size*0.3, 0, size*0.3, 0); abGrad.addColorStop(0, '#000'); abGrad.addColorStop(0.3, '#ffd700'); abGrad.addColorStop(0.7, '#ffd700'); abGrad.addColorStop(1, '#000');
                for(let i=0; i<5; i++) { const segY = size*0.3 + (i * size*0.25); const segW = (size*0.5) * (1 - i*0.15); const segH = size*0.3; ctx.fillStyle = (i % 2 === 0) ? '#111' : abGrad; ctx.beginPath(); ctx.ellipse(0, segY, segW, segH, 0, 0, Math.PI*2); ctx.fill(); }
                ctx.fillStyle = '#222'; ctx.beginPath(); ctx.ellipse(0, 0, size*0.4, size*0.45, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = modeColor; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(0, -size*0.3, size*0.2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
                ctx.translate(0, -size*0.5); ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.ellipse(0, 0, size*0.35, size*0.3, 0, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(-size*0.2, -size*0.1, size*0.1, size*0.15, -0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(size*0.2, -size*0.1, size*0.1, size*0.15, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#ffd700'; ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(-size*0.3, -size*0.4); ctx.lineTo(-size*0.4, -size*0.9); ctx.lineTo(0, -size*1.1); ctx.lineTo(size*0.4, -size*0.9); ctx.lineTo(size*0.3, -size*0.4); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.restore();
            }

            drawRealWorker(x, y, size, modeColor, w) {
                const ctx = this.ctx; ctx.save(); ctx.translate(x, y);
                if (this.state.mode === 'CODING') ctx.rotate(w.angle + Math.PI/2); 
                else if (this.state.mode === 'BUILDING') { const dx = x - (this.state.w/2); const dy = y - (this.state.h/2); ctx.rotate(Math.atan2(dy, dx) + Math.PI/2); }
                else if (this.state.mode === 'LISTENING') ctx.rotate(0); 
                else if (this.state.mode === 'TYPING') ctx.rotate(w.angle + Math.PI/2); 
                else ctx.rotate(w.angle + Math.PI/2);
                ctx.strokeStyle = '#000'; ctx.lineWidth = size * 0.1; for(let i=0; i<3; i++) { const ly = -size*0.2 + (i*size*0.3); ctx.beginPath(); ctx.moveTo(size*0.3, ly); ctx.lineTo(size*0.8, ly+size*0.3); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-size*0.3, ly); ctx.lineTo(-size*0.8, ly+size*0.3); ctx.stroke(); }
                const f = Math.sin(this.state.time * 0.5 + w.id); ctx.fillStyle = `rgba(${this.hexToRgb(modeColor)}, 0.2)`; ctx.beginPath(); ctx.ellipse(-size*0.7, size*0.2, size*0.8, size*0.4*(1+f*0.5), -0.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(size*0.7, size*0.2, size*0.8, size*0.4*(1+f*0.5), 0.5, 0, Math.PI*2); ctx.fill();
                const grad = ctx.createLinearGradient(-size*0.5, 0, size*0.5, 0); grad.addColorStop(0, '#000'); grad.addColorStop(0.4, '#eab308'); grad.addColorStop(0.6, '#eab308'); grad.addColorStop(1, '#000'); ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(0, size*0.6, size*0.55, size*0.7, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.beginPath(); ctx.rect(-size*0.5, size*0.5, size, size*0.2); ctx.fill(); ctx.beginPath(); ctx.rect(-size*0.4, size*0.9, size*0.8, size*0.15); ctx.fill();
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(0, -size*0.1, size*0.5, size*0.5, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -size*0.5, size*0.35, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = modeColor; ctx.beginPath(); ctx.arc(-size*0.2, -size*0.6, size*0.1, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(size*0.2, -size*0.6, size*0.1, 0, Math.PI*2); ctx.fill(); ctx.restore();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255,255,255';
            }

            animate() {
                this.update();
                this.draw();
                this.state.frameId = requestAnimationFrame(() => this.animate());
            }
        }

        const agent = new AgentBeeAnimation('agentWidget', 'agentCanvas');
    </script>
</body>
</html>


