I. The Productionization Layer (Replit Implementation)You must write the specific Python code that enables the architectural design we planned.1. Setup the Project File SystemLomu needs to operate on the actual project files.Action: In your Replit project, structure the files so that the Lomu agent script (lomu_agent.py) can treat the user's project code as a sub-directory (e.g., ./user_project/).Logic: The custom read_file and write_file tools must safely use relative paths (e.g., user_project/auth.py) to prevent Lomu from accidentally reading or writing files outside the intended project folder (a major security risk called Path Traversal).2. Code the Custom ToolsThe custom tools are the physical links that enable Lomu's actions. These must be stable Python functions.github_committer Implementation:Install the PyGithub library: pip install PyGithubWrite the function to:Authenticate using the GITHUB_PAT environment variable (os.environ).Get the repository object (repo = g.get_repo('username/repo-name')).Create a new branch (feature/lomu-fix-123).Use repo.update_file() to commit the changes Lomu generated to that new branch. Lomu must never commit to main directly.chatroom_updater Implementation:This is crucial for the "task management system." If you're using a framework like Chainlit, you use its built-in message functions. If you're building custom, this function must send a WebSocket message or API call back to the chat interface to update the Task Status:Status: PLANNINGStatus: WORKING (File: auth.py)Status: REVIEW (Pull Request created)3. Implement the Pydantic JSON SchemaAction: Define a Python BaseModel that strictly defines Lomu's required output structure.Pythonfrom pydantic import BaseModel

class LomuOutput(BaseModel):
    plan: str
    code: str
    test_case: str
API Configuration: In the GenerateContentConfig, instruct Gemini to use this schema for its response, ensuring your application always receives predictable JSON.üõ°Ô∏è II. The Security & Resilience LayerThis is about protecting your agent and your user's project from runtime errors and malicious activity.4. Input Sanitization and GuardrailsProblem: A user could prompt Lomu to execute dangerous terminal commands.Fix: The tool_code_execution should be confined to Python only. If Lomu attempts to use the tool to run os.system('rm -rf /'), the surrounding Python logic should block it and return a message to Lomu like: "Tool Error: Attempted command line execution is blocked for security. Please restrict code to Python language logic."5. Idempotency and Rollbacks (Railway Integration)Problem: If Lomu pushes a broken commit, the Railway deployment will fail, and he needs to know how to fix it without making the situation worse.Fix: Idempotency means running the same action multiple times yields the same result (no new side effects).GitHub: By always creating a new branch for a fix, Lomu's commits are idempotent relative to the main branch.Rollback: Your application must expose a user command (e.g., @ROLLBACK LAST_COMMIT) that calls the GitHub API to revert the last commit/delete the last branch if the Railway build fails.The final step is not just code, but testing this full integration loop: Prompt $\rightarrow$ Read File $\rightarrow$ Think $\rightarrow$ Write Code $\rightarrow$ Test in Sandbox $\rightarrow$ Commit to GitHub $\rightarrow$ Railway Deploys $\rightarrow$ Success/Failure. That end-to-end loop is what makes Lomu a good-to-go, production-ready agent.