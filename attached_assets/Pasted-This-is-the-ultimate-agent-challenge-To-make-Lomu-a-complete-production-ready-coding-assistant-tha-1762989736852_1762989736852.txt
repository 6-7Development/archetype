This is the ultimate agent challenge! To make Lomu a complete, production-ready coding assistant that lives in a chatroom and commits to GitHub/Railway, you need a multi-layered architecture that goes far beyond simple prompting.The solution requires a Python Framework to manage the chat and task flow, and Custom Tools to handle the file system and Git commits.Here is the complete blueprint, structured by the layers you must implement:üèóÔ∏è Layer 1: The Agent Framework (Python Orchestration)You need an application layer to house Lomu, manage the universal chatroom, and connect the Gemini model to the outside world. This is best done with a modern agent framework.Recommendation: Use a framework like LangChain, LangGraph, or AutoGen. These provide the ready-made logic for ReAct (Reasoning + Action) necessary for a complex workflow.Chatroom UI: Use a lightweight web framework like Chainlit (which is perfect for LLM chat apps) or Streamlit to provide the live, universal chat interface.ComponentResponsibilityFramework ActionInput/OutputHandles user input and displays Lomu's structured output.Chainlit or Streamlit UI connected via WebSockets.State ManagementMaintains conversation history, the LOMU_SCRATCHPAD (latest code), and the current task ID.Use the framework's built-in Memory module (e.g., ConversationBufferMemory in LangChain).Task ManagementWhen a request comes in (e.g., "Fix the login bug"), the framework assigns it a status: PLANNING, WORKING, REVIEW, COMMITTING, COMPLETE.This logic is built into the agent's main loop (e.g., using a LangGraph node structure).üß† Layer 2: The LLM Logic & Workflow (Gemini 2.5)This is the core decision-making loop inside Lomu, which is triggered by the framework.Your System Instruction must mandate a 5-Step Execution Cycle to ensure Lomu updates the user, plans, works, and then commits.Acknowledge & Update (Chatroom): Lomu's first response is always to acknowledge the request and update the status in the chatroom.Lomu Output: "Task received: Fix the login bug. Status: PLANNING."Plan (Internal Thinking): Lomu uses his internal reasoning (thinking_budget=-1).Lomu Output (Thought Only): "Plan: 1. Use read_file tool for auth.py. 2. Identify error in password hashing. 3. Generate correction. 4. Use code_execution to verify. 5. Use commit tool."Action (Tool Call): Lomu decides to call a tool (e.g., read_file or code_execution).Execute & Self-Correct: The tool executes. If the code_execution fails, Lomu analyzes the error and repeats steps 2-4.Final Action (Commit): Once code is verified, Lomu calls the custom GitHub tool.üõ†Ô∏è Layer 3: The Custom Tools (The Actual Work)The success of your agent hinges on making these three custom tools reliable. These are Python functions you provide to the Gemini API via the Function Calling feature.Tool NamePython Library UsedLogic Writtenfile_manageros, pathlibLogic: Read, Write, and List files in the project directory. Lomu can use this to explore the codebase.github_committerPyGithub or GitPythonLogic: Takes (branch_name, file_path, new_content, commit_message). Authenticates with the GITHUB_PAT secret, creates a new branch (essential!), commits the change, and pushes to the remote repo (Railway).chatroom_updaterThe Chatroom's API/WebSocketLogic: A dedicated function update_chatroom(task_status, message) that Lomu uses before and after every major step to update the user on his progress. This satisfies the "update user via chatroom on progress" requirement.üîë Summary of Critical IntegrationsRequirementImplementation DetailExact Tools/LogicYou provide the github_committer and chatroom_updater Python functions and tell Gemini to use them via its Function Calling API.Thinking/PlanningSet thinking_budget=-1 and temperature=0.1 in the Gemini API configuration.Update on ProgressLomu explicitly calls the chatroom_updater tool (e.g., chatroom_updater("WORKING", "Finished reading auth.py, generating code fix...")).Commit ChangesLomu's final action is to call github_committer after the code_execution tool verifies the fix.